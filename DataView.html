<!DOCTYPE html>
<html lang="en">
<head>
    <base target="_top">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Church & Service Information with Map</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/1.13.6/css/dataTables.bootstrap4.min.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
    <style>
    /* Your existing styles are preserved */
        body { padding-top: 56px; /* Add padding to body to offset fixed navbar */ font-family: Arial, sans-serif; }
        .container-fluid { max-width: 1140px; }
        .section-header { margin-top: 30px; margin-bottom: 15px; }
        table.dataTable th { background-color: #e9ecef; cursor: pointer; }
        .table-responsive { margin-top: 20px; }
        #statusMessage { margin-top: 15px; }
        .modal-body ul { padding-left: 20px; list-style-type: none; }
        .modal-body li { margin-bottom: 10px; padding-bottom: 5px; border-bottom: 1px dashed #eee; }
        .modal-body li:last-child { border-bottom: none; }
        .modal-body h5 { margin-top: 15px; }
        div.dataTables_length {
            display:none;
        }
        
        .view-services-btn, .show-map-btn { white-space: nowrap; }
        #mapModalLeaflet .modal-dialog { max-width: 90%; } 
        #mapCanvasLeaflet { height: 70vh; width: 100%; border: 1px solid #ccc; } 
        .map-controls { margin-bottom: 15px; text-align: center; }
            .btn-notification-bubble {
        font-size: 0.65rem;     /* Makes the font inside the bubble smaller */
        padding: 0.25em 0.5em;  /* Adjust padding to control bubble size; aim for circular with 1-2 digits */
        line-height: 1;         /* Ensures text is centered vertically */
        /* Bootstrap's 'badge rounded-pill bg-danger' will handle shape and color */
    }

    /* Optional: Adjust padding slightly if the count is high, e.g., for "99+" */
    .btn-notification-bubble.high-count {
        padding: 0.25em 0.4em;
    }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
      <div class="container-fluid">
        <a class="navbar-brand" href="#">Church & Service Information</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#mainNavbar" aria-controls="mainNavbar" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="mainNavbar">
          <ul class="navbar-nav ml-auto" id="dynamicNavLinks">
              </ul>
        </div>
      </div>
    </nav>
    <div class="container-fluid">
        <header class="my-4 text-center">
            <h1>Church Information</h1>
        </header>

        <div id="statusMessage" style="display: none;"></div>

        <div class="map-controls">
            <button id="showChurchesMapBtnLeaflet" class="btn btn-info btn-lg show-map-btn">Show All Churches on Map</button>
        </div>

        <div class="table-responsive">
            <table id="churchesInfoTable" class="table table-striped table-bordered table-hover table-sm" style="width:100%;">
                <thead class="thead-dark">
                    <tr>
                        <th>Church Name</th>
                        <th>Minister</th>
                        <th>Address</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="churchesTableBody">
                    <tr><td colspan="5" class="text-center">Loading church data...</td></tr>
                </tbody>
            </table>
        </div>
    </div>

    <div class="modal fade" id="servicesModal" tabindex="-1" role="dialog" aria-labelledby="servicesModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="servicesModalLabel">Regular Services</h5>
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
                </div>
                <div class="modal-body" id="servicesModalBody"><p>Loading services...</p></div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="mapModalLeaflet" tabindex="-1" role="dialog" aria-labelledby="mapModalLabelLeaflet" aria-hidden="true">
        <div class="modal-dialog modal-xl" role="document"> 
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="mapModalLabelLeaflet">Church Locations</h5>
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
                </div>
                <div class="modal-body">
                    <div id="mapCanvasLeaflet"></div>
                    <p class="text-muted mt-2"><small>Map tiles by OpenStreetMap. Pin locations based on provided coordinates or geocoded addresses.</small></p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-dismiss="modal">Close Map</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://code.jquery.com/jquery-3.7.0.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <script type="text/javascript" charset="utf8" src="https://cdn.datatables.net/1.13.6/js/jquery.dataTables.min.js"></script>
    <script type="text/javascript" charset="utf8" src="https://cdn.datatables.net/1.13.6/js/dataTables.bootstrap4.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <script>
        const SCRIPT_API_URL = 'https://script.google.com/macros/s/AKfycbz0svFL0DvyXVMc3ebkKaEyFwVSl3zWe1ff0qO5NQ1J66AlO8YSwYERGqxsZbDhR1K75g/exec';

        let allChurchesData = [];
        let allMinistersData = [];
        let allServicesData = [];
        let allSpecialEventsData = [];
        let churchesDataTable; 
        let leafletMap; 
        let leafletMarkers = []; // Keep track of markers to manage them

        async function populateNavbar() {
            try {
                const response = await fetch(`${SCRIPT_API_URL}?action=getNav`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const result = await response.json();
                if (result.error) throw new Error(result.error);
                
                const links = result.data;
                const navLinksContainer = document.getElementById('dynamicNavLinks');
                if (!navLinksContainer || !links) return;

                links.forEach(link => {
                    const li = document.createElement('li');
                    li.className = 'nav-item';
                    
                    const a = document.createElement('a');
                    a.className = 'nav-link';
                    a.href = link.url;
                    a.textContent = link.title;
                    // Adjust your base URL if it's different
                    if (!link.url.startsWith('https://d3rkrox.github.io')) { 
                       a.target = '_blank';
                    }
                    li.appendChild(a);
                    navLinksContainer.appendChild(li);
                });
            } catch (e) {
                console.error("Could not populate navbar:", e);
            }
        }

        function displayStatus(message, isError = false, autoClear = true) {
            const statusMsg = document.getElementById("statusMessage");
            if (!statusMsg) return;
            statusMsg.textContent = message;
            statusMsg.className = isError ? "alert alert-danger mt-3" : "alert alert-info mt-3";
            statusMsg.style.display = 'block';
            if (!isError && autoClear && message !== "Loading data...") {
                setTimeout(() => { 
                    if (statusMsg.textContent === message) {
                        statusMsg.textContent = ""; 
                        statusMsg.className=""; 
                        statusMsg.style.display = 'none';
                    }
                }, 5000);
            }
        }
        async function fetchSheetDataForStaticPage(sheetName) {
            try {
                const response = await fetch(`${SCRIPT_API_URL}?action=getSheetData&sheet=${sheetName}`);
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status} for ${sheetName}`);
                const result = await response.json();
                if (result.error) throw new Error(`API error for ${sheetName}: ${result.error}`);
                // console.log(`Fetched ${sheetName}:`, result.data ? result.data.slice(0,3) : 'No data'); 
                return result.data || [];
            } catch (error) {
                console.error(`Error fetching ${sheetName}:`, error);
                displayStatus(`Failed to load ${sheetName}: ${error.message}`, true, false);
                return []; 
            }
        }
        function initializeDataTable(tableId) {
            if ($.fn.DataTable.isDataTable(`#${tableId}`)) {
                 $(`#${tableId}`).DataTable().destroy();
                 $(`#${tableId} tbody`).empty(); 
            }
            churchesDataTable = $(`#${tableId}`).DataTable({
                "pageLength": -1,
               // "lengthMenu": [ [10, 25, 75, -1], [10, 25, 75, "All"] ],
                "destroy": true 
            });
        }
        function populateChurchesTable() {
            const tbody = document.getElementById("churchesTableBody");
            if (!tbody) { console.error("populateChurchesTable: churchesTableBody element not found!"); return; }

            if ($.fn.DataTable.isDataTable('#churchesInfoTable')) {
                $('#churchesInfoTable').DataTable().destroy();
            }
            tbody.innerHTML = ""; 

            if (allChurchesData && allChurchesData.length > 0) {
                allChurchesData.forEach(church => {
                    if (!church) return; 
                    const row = tbody.insertRow();
                    row.insertCell().textContent = church.ChurchName || "N/A";
                    let ministerName = "N/A";
                    let ministerIdToFind = church.MinisterID || church.LeadMinisterID; 
                    if (ministerIdToFind && allMinistersData && allMinistersData.length > 0) {
                        const minister = allMinistersData.find(m => m && String(m.MinisterID).trim() === String(ministerIdToFind).trim());
                        if (minister) ministerName = minister.Name || "N/A";
                    }
                    row.insertCell().textContent = ministerName;
                    const addressCell = row.insertCell();
                    if (church.Address) { 
                        const encodedAddress = encodeURIComponent(church.Address);
                        addressCell.innerHTML = `<a href="https://maps.google.com/?q=${encodedAddress}" target="_blank">${church.Address}</a>`; // Corrected Google Maps link
                    } else { addressCell.textContent = "N/A"; }
                    
                    const actionsCell = row.insertCell();
                    const churchNameAttr = church.ChurchName ? church.ChurchName.replace(/"/g, '&quot;') : 'Selected Church'; // Sanitize for attribute
                    const upcomingEventCount = getUpcomingSpecialEventCountForChurch(church.ChurchID);
                    /*
                    let buttonClass = "btn-info"; // Default button color
                    let buttonText = "View Services";

                    if (upcomingEventCount > 0) {
                        buttonClass = "btn-success"; // Change color if there are upcoming events
                        buttonText += ` <span class="badge bg-light text-dark ms-1">${upcomingEventCount}</span>`; // Add badge
                    }
                    actionsCell.innerHTML = `<button type="button" class="btn btn-sm ${buttonClass} view-services-btn" data-churchid="${church.ChurchID}" data-churchname="${churchNameAttr}">${buttonText}</button>`;
                    //actionsCell.innerHTML = `<button type="button" class="btn btn-sm btn-info view-services-btn" data-churchid="${church.ChurchID || ''}" data-churchname="${churchNameAttr}">View Services</button>`;
                    */
                   let buttonClasses = "btn btn-sm btn-info view-services-btn";
                    if (upcomingEventCount > 0) {
                        buttonClasses += " position-relative"; // Needed for absolute positioning of the bubble
                    }

                    let buttonHtml = `<button type="button" class="${buttonClasses}" data-churchid="${church.ChurchID}" data-churchname="${churchNameAttr}">View Services`;

                    if (upcomingEventCount > 0) {
                        const displayCount = upcomingEventCount > 99 ? "99+" : upcomingEventCount;
                        const countClass = upcomingEventCount > 9 ? "high-count" : ""; // Optional class for higher counts
                        buttonHtml += `
                            <span class="position-absolute top-0 start-100 translate-middle badge rounded-pill bg-danger btn-notification-bubble ${countClass}">
                                ${displayCount}
                            </span>
                        `;
                    }
                    buttonHtml += `</button>`;
                    actionsCell.innerHTML = buttonHtml;
                });
                initializeDataTable('churchesInfoTable'); 
                attachServiceButtonListeners();
            } else {
                tbody.innerHTML = '<tr><td colspan="5" class="text-center">No churches found.</td></tr>';
            }
        }
        function attachServiceButtonListeners() {
            $('#churchesInfoTable tbody').off('click', 'button.view-services-btn').on('click', 'button.view-services-btn', function () {
                const churchId = $(this).data('churchid');
                const churchName = $(this).data('churchname');
                if (churchId) displayServicesInModal(String(churchId), churchName);
                else console.error("View Services button clicked without a churchId.");
            });
        }
        
        function displayServicesInModal(churchId, churchName) {
        const modalTitle = document.getElementById("servicesModalLabel");
        const modalBody = document.getElementById("servicesModalBody");

        if (!modalTitle || !modalBody) {
            console.error("Services modal elements not found!");
            return;
        }

        modalTitle.textContent = `Services & Special Events for ${churchName}`;
        let html = "";

        // --- Part 1: Regular Service Schedule (Restored to previous working logic) ---
        const servicesForChurch = allServicesData.filter(
            s => s && String(s.ChurchID).trim() === String(churchId).trim()
        );

        html += "<h4>Regular Service Schedule</h4>";
        if (servicesForChurch.length === 0) {
            html += "<p>No regular services listed for this church.</p>";
        } else {
            const weeklyServices = servicesForChurch.filter(s => s.RecurrenceType === 'Weekly');
            const monthlyNthServices = servicesForChurch.filter(s => s.RecurrenceType === 'MonthlyNthWeekday');
            const monthlyRelativeServices = servicesForChurch.filter(s => s.RecurrenceType === 'MonthlyRelativeToRule');

            // Display Weekly Services
            if (weeklyServices.length > 0) {
                html += "<h5>Weekly Services</h5><ul>";
                const weeklyByDay = {};
                const dayOrder = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
                weeklyServices.forEach(s => {
                    if (!s.DayOfWeek) return; // Skip if DayOfWeek is missing
                    if (!weeklyByDay[s.DayOfWeek]) weeklyByDay[s.DayOfWeek] = [];
                    weeklyByDay[s.DayOfWeek].push(s);
                });
                dayOrder.forEach(day => {
                    if (weeklyByDay[day] && weeklyByDay[day].length > 0) {
                        html += `<li class="mb-2"><strong>${day}:</strong><ul>`;
                        weeklyByDay[day]
                            .sort((a,b) => (parseSimpleTimeForSort(a.Time) || 0) - (parseSimpleTimeForSort(b.Time) || 0))
                            .forEach(s => {
                                let title = s.ServiceTitle || "Service";
                                if ((s.IsCommunionFlag === true || String(s.IsCommunionFlag).toLowerCase() === 'true') && !title.toLowerCase().includes("communion")) {
                                    title += " (Communion)";
                                }
                                let duration = s.DurationMinutes ? ` (${s.DurationMinutes} mins)` : '';
                                html += `<li>${title} at ${s.Time || 'N/A'}</li>`; 
                            });
                        html += `</ul></li>`;
                    }
                });
                html += "</ul>";
            } else {
                 html += "<h5>Weekly Services</h5><p>No regular weekly services listed.</p>";
            }
            html += "<hr>";

            // Display Monthly Nth Weekday Services
            if (monthlyNthServices.length > 0) {
                const monthlyNthByTitle = {};
                monthlyNthServices.forEach(s => {
                    const titleKey = s.ServiceTitle || "Untitled Monthly Service";
                    if (!monthlyNthByTitle[titleKey]) monthlyNthByTitle[titleKey] = [];
                    monthlyNthByTitle[titleKey].push(s);
                });
                for (const serviceTitleKey in monthlyNthByTitle) {
                    html += `<h5>${serviceTitleKey}</h5><ul>`;
                    monthlyNthByTitle[serviceTitleKey].sort((a,b) => { 
                        const nthOrder = ["1st", "2nd", "3rd", "4th", "Last"];
                        const dayOrderVal = {"Sunday":0, "Monday":1, "Tuesday":2, "Wednesday":3, "Thursday":4, "Friday":5, "Saturday":6};
                        let comparison = (nthOrder.indexOf(a.NthOccurrence) || 5) - (nthOrder.indexOf(b.NthOccurrence) || 5) ;
                        if (comparison === 0) comparison = (dayOrderVal[a.DayOfWeek] !== undefined ? dayOrderVal[a.DayOfWeek] : 7) - (dayOrderVal[b.DayOfWeek] !== undefined ? dayOrderVal[b.DayOfWeek] : 7);
                        if (comparison === 0) comparison = (parseSimpleTimeForSort(a.Time) || 0) - (parseSimpleTimeForSort(b.Time) || 0);
                        return comparison;
                    }).forEach(s => {
                        html += `<li>${formatServiceRuleDescription(s, churchId, serviceTitleKey)}</li>`;
                    });
                    html += `</ul>`;
                }
                 html += "<hr>";
            } else { html += "<h5>Monthly Services</h5><p>No Nth weekday services listed.</p><hr>"; }

            // Display Monthly Relative Services
            if (monthlyRelativeServices.length > 0) {
                const monthlyRelativeByTitle = {};
                 monthlyRelativeServices.forEach(s => {
                    const titleKey = s.ServiceTitle || "Untitled Relative Service";
                    if (!monthlyRelativeByTitle[titleKey]) monthlyRelativeByTitle[titleKey] = [];
                    monthlyRelativeByTitle[titleKey].push(s);
                });
                for (const serviceTitleKey in monthlyRelativeByTitle) {
                    html += `<h5>${serviceTitleKey}</h5><ul>`;
                    monthlyRelativeByTitle[serviceTitleKey].sort((a,b) => (formatServiceRuleDescription(a, churchId, serviceTitleKey)).localeCompare(formatServiceRuleDescription(b, churchId, serviceTitleKey)))
                        .forEach(s => {
                            html += `<li>${formatServiceRuleDescription(s, churchId, serviceTitleKey)}</li>`;
                        });
                    html += `</ul>`;
                }
            } else { html += "<h5>Other Monthly Services</h5><p>No relative monthly services listed.</p>"; }
        }
        html += "<hr class='my-3'>"; // Separator before special events

        // --- Part 2: Upcoming & Ongoing Special Events (Revivals, Singings, Fundraisers) ---
        html += "<h4>Upcoming & Ongoing Special Events</h4>";
        
        const specialEventTypesToShow = ["revival", "singing", "fundraiser"]; 
        
        const specialEventsForThisChurch = allSpecialEventsData.filter(event => 
            event && 
            String(event.ChurchID).trim() === String(churchId).trim() &&
            specialEventTypesToShow.includes(String(event.EventType || "").trim().toLowerCase()) &&
            (String(event.isGeneratedInstance).toLowerCase() !== 'true') // Only show parents or single non-series events
        );

        const today = new Date(); 
        today.setHours(0, 0, 0, 0); // Today at midnight in local timezone
        const relevantSpecialEvents = [];

        specialEventsForThisChurch.forEach(event => {
            if (!event.StartDate) return;

            const eventStart = new Date(event.StartDate); // Converts UTC ISO string to local Date object
            const eventEnd = event.EndDate ? new Date(event.EndDate) : new Date(eventStart); 
            const isAllDay = String(event.IsAllDay).toLowerCase() === 'true';

            // Get the date part only, in local timezone for comparison
            const eventStartDateOnly = new Date(eventStart.getFullYear(), eventStart.getMonth(), eventStart.getDate());
            
            let eventLastDayInclusive;
            if (isAllDay) {
                // For all-day events, the EndDate from cache is exclusive UTC.
                // To get the last inclusive day in local time:
                let exclusiveEndLocal = new Date(eventEnd.getFullYear(), eventEnd.getMonth(), eventEnd.getDate());
                eventLastDayInclusive = new Date(exclusiveEndLocal.setDate(exclusiveEndLocal.getDate() - 1));
            } else {
                // For timed events, the EndDate is the actual end moment. We just need its date part.
                eventLastDayInclusive = new Date(eventEnd.getFullYear(), eventEnd.getMonth(), eventEnd.getDate());
            }
             // Ensure last day is not before start day if duration is short or end date is missing/same
            if (eventLastDayInclusive < eventStartDateOnly) eventLastDayInclusive = new Date(eventStartDateOnly);


            const isOngoing = (today >= eventStartDateOnly && today <= eventLastDayInclusive);
            const isFuture = (eventStartDateOnly > today);

            if (isOngoing || isFuture) {
                relevantSpecialEvents.push(event);
            }
        });

        if (relevantSpecialEvents.length > 0) {
            html += "<ul class='list-unstyled mt-3'>";
            relevantSpecialEvents.sort((a,b) => new Date(a.StartDate) - new Date(b.StartDate)); 
            
            relevantSpecialEvents.forEach(event => {
                let title = event.EventType || "Special Event";

                const startDate = new Date(event.StartDate);
                const endDate = event.EndDate ? new Date(event.EndDate) : startDate; // Use start if end is missing
                const isAllDay = String(event.IsAllDay).toLowerCase() === 'true';
                
                const dateOptions = { year: 'numeric', month: 'long', day: 'numeric' };
                const timeOptions = { hour: 'numeric', minute:'2-digit' };
                
                let dateString = startDate.toLocaleDateString(undefined, dateOptions);
                
                if (isAllDay) {
                    let actualEndDate = new Date(endDate.getTime());
                    actualEndDate.setDate(actualEndDate.getUTCDate() -1); // Make inclusive for display
                    // Only show range if it's truly multi-day
                    if (actualEndDate.getTime() > startDate.getTime()) { 
                         dateString += ` - ${actualEndDate.toLocaleDateString(undefined, dateOptions)}`;
                    }
                } else {
                    dateString = `${startDate.toLocaleDateString(undefined, dateOptions)}`;
                    if (endDate.getTime() > startDate.getTime()) { // Only show end time if different from start
                        if (startDate.toDateString() === endDate.toDateString()) {
                            dateString += ` - ${endDate.toLocaleTimeString(undefined, timeOptions)}`;
                        } else {
                            dateString += ` - ${endDate.toLocaleDateString(undefined, dateOptions)}`;
                        }
                    }
                }
                
                html += `<li class="mb-3"><strong class="d-block">${title}</strong><small class="text-muted">When: ${dateString}</small>`;
                if (event.Description) { 
                    html += `<br><small class="d-block mt-1"><em>Details:</em><br>${event.Description.replace(/\n/g, '<br>')}</small>`;
                }
                html += `</li>`;
            });
            html += "</ul>";
        } else {
            html += "<p>No upcoming Revivals, Singings, or Fundraisers listed for this church.</p>";
        }

        modalBody.innerHTML = html;
        $('#servicesModal').modal('show');
    }
    function getUpcomingSpecialEventCountForChurch(churchId) {
        if (!allSpecialEventsData || !allChurchesData) return 0; // Ensure necessary data is loaded

        const specialEventTypesToCount = ["revival", "singing", "fundraiser"]; 

        const specialEventsForThisChurch = allSpecialEventsData.filter(event =>
            event &&
            String(event.ChurchID).trim() === String(churchId).trim() &&
            specialEventTypesToCount.includes(String(event.EventType || "").trim().toLowerCase()) &&
            (String(event.isGeneratedInstance).toLowerCase() !== 'true') // Consider only parent series or single events
        );

        const today = new Date();
        today.setHours(0, 0, 0, 0); // Today at midnight in local timezone
        let count = 0;

        specialEventsForThisChurch.forEach(event => {
            if (!event.StartDate) return;

            const eventStart = new Date(event.StartDate); // Converts UTC ISO string to local Date object
            const eventEnd = event.EndDate ? new Date(event.EndDate) : new Date(eventStart);
            const isAllDay = String(event.IsAllDay).toLowerCase() === 'true';

            const eventStartDateOnly = new Date(eventStart.getFullYear(), eventStart.getMonth(), eventStart.getDate());
            
            let eventLastDayInclusive;
            if (isAllDay) {
                let exclusiveEndLocal = new Date(eventEnd.getFullYear(), eventEnd.getMonth(), eventEnd.getDate());
                eventLastDayInclusive = new Date(exclusiveEndLocal.setDate(exclusiveEndLocal.getDate() - 1));
            } else {
                eventLastDayInclusive = new Date(eventEnd.getFullYear(), eventEnd.getMonth(), eventEnd.getDate());
            }
            if (eventLastDayInclusive < eventStartDateOnly) { // Handle single-day timed events where end date might be same as start date
                 eventLastDayInclusive = new Date(eventStartDateOnly);
            }

            const isOngoing = (today.getTime() >= eventStartDateOnly.getTime() && today.getTime() <= eventLastDayInclusive.getTime());
            const isFuture = (eventStartDateOnly.getTime() > today.getTime());

            if (isOngoing || isFuture) {
                count++;
            }
        });
        return count;
    }

        function parseSimpleTimeForSort(timeStr) { 
            if (!timeStr || typeof timeStr !== 'string') return null;
            const match = timeStr.match(/(\d+):(\d+)\s*(AM|PM)?/i);
            if (!match) return null;
            let hours = parseInt(match[1], 10);
            const minutes = parseInt(match[2], 10);
            const modifier = match[3] ? match[3].toUpperCase() : null;
            if (modifier === "PM" && hours < 12) hours += 12;
            if (modifier === "AM" && hours === 12) hours = 0;
            return hours * 60 + minutes; 
        }

        function parseTime(timeString) { // Ensure this helper is present
        if (!timeString || typeof timeString !== 'string' || timeString.trim() === "") return null;
        const match = timeString.match(/(\d+):(\d+)\s*(AM|PM)?/i);
        if (!match) return null;
        let hours = parseInt(match[1], 10);
        const minutes = parseInt(match[2], 10);
        const modifier = match[3] ? match[3].toUpperCase() : null;
        if (modifier === "PM" && hours < 12) hours += 12;
        if (modifier === "AM" && hours === 12) hours = 0;
        return { hours, minutes };
    }


function formatServiceRuleDescription(service, churchId, serviceHeaderTitle = "") {
        let description = "";
        // Use the service's own title for communion check if header title isn't passed reliably for this specific check
        let lowerServiceOwnTitle = (service.ServiceTitle || "").toLowerCase(); 

        let timeText = service.Time ? ` at ${service.Time}` : '';
        let durationText = service.DurationMinutes ? ` (${service.DurationMinutes} mins)` : '';
        
        let communionSuffix = ""; 
        // Add communion suffix if IsCommunionFlag is true AND the ServiceTitle itself doesn't already say "Communion"
        if ((service.IsCommunionFlag === true || String(service.IsCommunionFlag).toLowerCase() === 'true') && 
            !lowerServiceOwnTitle.includes("communion")) {
            communionSuffix = " (Communion)";
        }

        if (service.RecurrenceType === 'MonthlyNthWeekday') {
            description = `The ${service.NthOccurrence || ''} ${service.DayOfWeek || ''} of the month`;
            return `${description}${communionSuffix}`; // Time/duration previously removed for this type

        } else if (service.RecurrenceType === 'MonthlyRelativeToRule') {
            // Check if THIS service's title is "Communion" or "Communion Service" for special formatting
            if (lowerServiceOwnTitle === 'communion' || lowerServiceOwnTitle === 'communion service') {
                let parsedTime = parseTime(service.Time);
                if (parsedTime && parsedTime.hours >= 16) { // 4 PM (16:00) or later is "Evening"
                    return `${service.DayOfWeek || 'Day not specified'} Evening`;
                } else if (service.Time) { // It's communion, has a time, but not evening
                    return `${service.DayOfWeek || 'Day not specified'} at ${service.Time}`;
                } else { // It's communion, but no time specified in its row
                     return `${service.DayOfWeek || 'Day not specified'}`;
                }
            }
            
            // Logic for OTHER "MonthlyRelativeToRule" services (not titled "Communion/Communion Service")
            let baseRuleDesc = service.RelativeToServiceID || 'specified rule';
            if (typeof allServicesData !== 'undefined' && allServicesData.length > 0) {
                const baseService = allServicesData.find(s_lookup => 
                    s_lookup.ServiceID === service.RelativeToServiceID && 
                    s_lookup.ChurchID === churchId 
                );
                if (baseService && baseService.ServiceTitle) {
                    baseRuleDesc = `"${baseService.ServiceTitle}" (${service.RelativeToServiceID})`; // Include ID for clarity
                }
            }
            
            let offsetDesc = "";
            const offsetDays = parseInt(service.RelativeOffsetDays, 10);
            if (offsetDays === 0) offsetDesc = "on the same day as";
            else if (offsetDays === -1) offsetDesc = "the day before";
            else if (offsetDays === 1) offsetDesc = "the day after";
            else if (offsetDays < -1) offsetDesc = `${Math.abs(offsetDays)} days before`;
            else if (offsetDays > 1) offsetDesc = `${offsetDays} days after`;
            else offsetDesc = ""; 

            description = `${service.DayOfWeek || 'Day not specified'}${timeText}, ${offsetDesc} ${baseRuleDesc}`;
            return `${description}${communionSuffix}${durationText}`;

        } else if (service.RecurrenceType === 'Weekly') {
            // Weekly services are now primarily formatted directly in displayServicesInModal.
            // This is a fallback if this helper is called for a weekly type.
            description = `Every ${service.DayOfWeek || ''}${timeText}`;
            return `${description}${communionSuffix}${durationText}`;
        } else {
            description = `Rule: ${service.RecurrenceRule || 'Not specified'}${timeText}`; // Fallback
            return `${description}${communionSuffix}${durationText}`;
        }
    }


        async function geocodeAddressWithNominatim(address) {
            const encodedAddress = encodeURIComponent(address);
            const headers = new Headers({ 'User-Agent': 'ChurchDenominationMap/1.0 (ChurchApp@gmail.com)' }); // Replace with your info
            const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodedAddress}&limit=1`;
            try {
                const response = await fetch(url, { headers: headers });
                if (!response.ok) throw new Error(`Nominatim HTTP error! Status: ${response.status}`);
                const data = await response.json();
                if (data && data.length > 0 && data[0].lat && data[0].lon) { 
                    return { lat: parseFloat(data[0].lat), lng: parseFloat(data[0].lon) };
                } else {
                    console.warn(`Address not found or no coordinates from Nominatim: ${address}`);
                    return null; 
                }
            } catch (error) {
                console.warn(`Geocoding failed for ${address} with Nominatim:`, error);
                return null; 
            }
        }

        function fitMapToMarkers() {
            if (!leafletMap || leafletMarkers.length === 0) return;

            const featureGroup = L.featureGroup(leafletMarkers);
            const mapBounds = featureGroup.getBounds();

            if (mapBounds.isValid()) {
                //console.log("Fitting bounds:", mapBounds.toBBoxString());
                leafletMap.fitBounds(mapBounds.pad(0.1)); // Add some padding

                // If only one marker, or if fitBounds results in a very high zoom (too close), set a specific zoom.
                if (leafletMarkers.length === 1) {
                    leafletMap.setZoom(13); // Zoom level for a single marker
                } else if (leafletMap.getZoom() > 15) { // Don't zoom in too extremely if markers are very close
                    leafletMap.setZoom(15);
                }
                // Optional: If markers are very far apart, fitBounds might zoom out too much.
                // You could enforce a minimum zoom level, but this might cut off some markers.
                // else if (leafletMap.getZoom() < 5) {
                //     leafletMap.setZoom(5);
                // }
            } else if (leafletMarkers.length === 1 && leafletMarkers[0].getLatLng()) {
                // Fallback if bounds somehow invalid but one marker exists
                leafletMap.setView(leafletMarkers[0].getLatLng(), 13);
            } else {
                console.warn("Map bounds invalid or no markers to fit. Map view may not be optimal.");
            }
        }


        async function showMapWithLeafletPins() {
            if (typeof L === 'undefined') {
                displayStatus("Map library (Leaflet) not ready. Please wait or refresh.", true, false);
                return;
            }
            const mapElement = document.getElementById('mapCanvasLeaflet');
            if (!mapElement) { console.error("mapCanvasLeaflet element not found!"); return; }
            
            // Clear previous markers from the map and the array
            if (leafletMarkers.length > 0) {
                leafletMarkers.forEach(marker => marker.remove());
                leafletMarkers = [];
            }

            if (!leafletMap) { // Initialize map only once, or re-initialize if needed
                let mapCenter = [34.730369, -86.586105]; // Default: Huntsville, AL
                leafletMap = L.map(mapElement).setView(mapCenter, 6); 
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                    maxZoom: 18,
                }).addTo(leafletMap);
            } else {
                // If map exists, ensure it's cleared of old layers if you're not using featureGroup for everything
            }


            if (!allChurchesData || allChurchesData.length === 0) {
                displayStatus("No church data to display on map.", true, false);
                $('#mapModalLeaflet').modal('show'); 
                mapElement.innerHTML = "<p class='text-center p-5'>No church locations to display.</p>";
                return;
            }
            
            let geocodePromises = [];
            // leafletMarkers array is already cleared above

            allChurchesData.forEach(church => {
                if (!church) return;
                const churchName = church.ChurchName || "Church";
                const churchAddress = church.Address || "";
                const popupContent = `<strong>${churchName}</strong><br>${churchAddress}`;

                if (church.Latitude && church.Longitude && 
                    !isNaN(parseFloat(church.Latitude)) && !isNaN(parseFloat(church.Longitude))) {
                    
                    const lng = parseFloat(church.Latitude);
                    const lat = parseFloat(church.Longitude);
                    // console.log(`Using direct Lat/Lng for ${churchName}: Lat: ${lat}, Lng: ${lng}`);
                    const marker = L.marker([lat, lng]).bindPopup(popupContent);
                    leafletMarkers.push(marker); // Add to global array for later use by fitMapToMarkers
                } else if (churchAddress && String(churchAddress).trim() !== "") { 
                    geocodePromises.push(
                        geocodeAddressWithNominatim(churchAddress).then(coords => {
                            if (coords && !isNaN(coords.lat) && !isNaN(coords.lng)) { 
                                // console.log(`Geocoded ${churchName} (${churchAddress}): [${coords.lat}, ${coords.lng}]`);
                                const marker = L.marker([coords.lat, coords.lng]).bindPopup(popupContent); 
                                leafletMarkers.push(marker);
                            } else {
                                // console.log(`Geocoding returned null for ${churchName} (${churchAddress})`);
                            }
                        })
                    );
                }
            });

            function displayAndFitMap() {
                if (leafletMarkers.length > 0) {
                    leafletMarkers.forEach(marker => marker.addTo(leafletMap));
                    fitMapToMarkers(); // Use the new helper function
                } else {
                    mapElement.innerHTML = "<p class='text-center p-5'>No valid church locations could be mapped.</p>";
                    displayStatus("No locations could be mapped.", true, false);
                     // Optionally reset to default view if no markers
                    leafletMap.setView([34.730369, -86.586105], 6);
                }
                leafletMap.invalidateSize(); // Call after markers are added AND modal is visible
            }

            $('#mapModalLeaflet').modal('show'); // Show modal first

            // Handle map rendering after modal is fully shown and geocoding (if any) is done
            $('#mapModalLeaflet').off('shown.bs.modal').on('shown.bs.modal', function () { 
                if (leafletMap) leafletMap.invalidateSize(); // Invalidate size immediately when modal is shown

                if (geocodePromises.length > 0) {
                    displayStatus("Geocoding addresses... this may take a moment.", false, false);
                    Promise.allSettled(geocodePromises)
                        .then(() => {
                            displayAndFitMap();
                        });
                } else {
                    displayAndFitMap(); // No geocoding, just display and fit
                }
            });
        }

        document.getElementById("showChurchesMapBtnLeaflet").addEventListener("click", showMapWithLeafletPins);
        async function loadInitialData() {
            displayStatus("Loading data...", false, false); 
            try {
                const [churches, ministers, services,specialEvents ] = await Promise.all([
                    fetchSheetDataForStaticPage("Churches"),
                    fetchSheetDataForStaticPage("Ministers"),
                    fetchSheetDataForStaticPage("Services"),
                     fetchSheetDataForStaticPage("Events")
                ]);
                allChurchesData = churches || [];
                allMinistersData = ministers || [];
                allServicesData = services || [];
                allSpecialEventsData = specialEvents || [];
                populateChurchesTable();
                displayStatus("Data loaded successfully!", false, true);
            } catch (err) {
                console.error("General error during loadInitialData:", err);
                displayStatus("A general error occurred while loading data.", true, false);
                const tbody = document.getElementById("churchesTableBody");
                if(tbody) tbody.innerHTML = `<tr><td colspan="5" class="text-center">Error loading data.</td></tr>`;
            }
        }

        window.onload = function() {
            populateNavbar();
            if(typeof $ !== 'undefined' && $.fn.DataTable && typeof L !== 'undefined') {
                loadInitialData();
            } else { 
                let missing = [];
                if(typeof $ === 'undefined') missing.push("jQuery");
                if(typeof $.fn.DataTable === 'undefined') missing.push("DataTables");
                if(typeof L === 'undefined') missing.push("Leaflet");
                const errorMsg = `Error: Required page components (${missing.join(', ')}) not loaded. Check script tags.`;
                console.error(errorMsg);
                displayStatus(errorMsg, true, false);
            }
        };
    </script>
</body>
</html>
